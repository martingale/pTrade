from pyalgotrade import barfeed
from pyalgotrade.dataseries import resampled
from pyalgotrade import resamplebase
from pyalgotrade import bar


class BarsGrouper(resamplebase.Grouper):
    def __init__(self, groupDateTime, bars, frequency):
        resamplebase.Grouper.__init__(self, groupDateTime)
        self.__barGroupers = {}
        self.__frequency = frequency

        # Initialize BarGrouper instances for each instrument.
        for instrument, bar_ in bars.items():
            barGrouper = resampled.BarGrouper(groupDateTime, bar_, frequency)
            self.__barGroupers[instrument] = barGrouper

    def addValue(self, value):
        # Update or initialize BarGrouper instances for each instrument.
        for instrument, bar_ in value.items():
            barGrouper = self.__barGroupers.get(instrument)
            if barGrouper:
                barGrouper.addValue(bar_)
            else:
                barGrouper = resampled.BarGrouper(self.getDateTime(), bar_, self.__frequency)
                self.__barGroupers[instrument] = barGrouper

    def removeValue(self, value):
        for instrument, bar_ in value.items():
            barGrouper = self.__barGroupers.get(instrument)
            if barGrouper:


    def getGrouped(self):
        bar_dict = {}
        for instrument, grouper in self.__barGroupers.items():
            bar_dict[instrument] = grouper.getGrouped()
        return bar.Bars(bar_dict)


class ResampledBarFeed(barfeed.BaseBarFeed):

    def __init__(self, barFeed, frequency, maxLen=None):
        super(ResampledBarFeed, self).__init__(frequency, maxLen)

        if not isinstance(barFeed, barfeed.BaseBarFeed):
            raise Exception("barFeed must be a barfeed.BaseBarFeed instance")

        if not resamplebase.is_valid_frequency(frequency):
            raise Exception("Unsupported frequency")

        # Register the same instruments as in the underlying barfeed.
        for instrument in barFeed.getRegisteredInstruments():
            self.registerInstrument(instrument)

        self.__values = []
        self.__barFeed = barFeed
        self.grouper = None
        self.__range = None
        self.grouper2 = None
        self.__switch = False

        barFeed.getNewValuesEvent().subscribe(self.__onNewValues)

    def __onNewValues(self, dateTime, value):
        if self.__range is None:
            self.__range = resamplebase.build_range(dateTime, self.getFrequency())
            self.grouper = BarsGrouper(self.__range.getBeginning(), value, self.getFrequency())
        elif self.__range.belongs(dateTime):
            self.grouper.removeValue(value)
            self.grouper.addValue(value)
            self.__values.append(self.grouper.getGrouped())
            self.__range = resamplebase.build_range(dateTime, self.getFrequency())
            self.grouper = BarsGrouper(self.__range.getBeginning(), value, self.getFrequency())
        else:
            self.__values.append(self.grouper.getGrouped())
            self.__range = resamplebase.build_range(dateTime, self.getFrequency())
            self.grouper = BarsGrouper(self.__range.getBeginning(), value, self.getFrequency())

    def getCurrentDateTime(self):
        return self.__barFeed.getCurrentDateTime()

    def barsHaveAdjClose(self):
        return self.__barFeed.barsHaveAdjClose()

    def getNextBars(self):
        ret = None
        if len(self.__values):
            ret = self.__values.pop(0)
        return ret

    def eof(self):
        return len(self.__values) == 0

    def join(self):
        pass

    def peekDateTime(self):
        # We can't determine when the next event will be generated since it'll
        # depend on the values generated by the barfeed being wrapped.
        return None

    def start(self):
        super(ResampledBarFeed, self).start()

    def stop(self):
        pass

    def checkNow(self, dateTime):
        if self.__range is not None and not self.__range.belongs(dateTime):
            self.__values.append(self.grouper.getGrouped())
            self.grouper = None
            self.__range = None
            self.__switch = not self.__switch
        elif self.__range is not None and self.__range.belongs(dateTime):
            if self.__switch:
                self.__values.append(self.grouper.getGrouped())
                self.__switch = not self.__switch
            else:
                self.__values.pop()
                self.__values.append(self.grouper.getGrouped())
